
import { supabase } from '@/lib/supabaseClient';
import type { Product, Review } from '@/types';

// Helper to map DB snake_case to Product interface camelCase
const mapProductFromDB = (dbProduct: any): Product => {
    return {
        id: dbProduct.id,
        name: dbProduct.name,
        description: dbProduct.description,
        price: Number(dbProduct.price), // Ensure number
        originalPrice: dbProduct.original_price ? Number(dbProduct.original_price) : undefined,
        categoryId: dbProduct.category_id,
        category: dbProduct.categories?.name || dbProduct.category_id, // Join or raw ID fallback
        brand: dbProduct.brand,
        imageUrl: dbProduct.image_url,
        hoverImageUrl: dbProduct.hover_image_url,
        stock: dbProduct.stock,
        barcode: dbProduct.barcode,
        rating: Number(dbProduct.rating),
        salesCount: dbProduct.sales_count,
        isNewRelease: dbProduct.is_new_release,
        sizes: dbProduct.sizes || [],   // Added mapping
        colors: dbProduct.colors || [], // Added mapping
        flavors: dbProduct.flavors || [], // Added mapping
        weights: dbProduct.weights || [], // Added mapping
        // Reviews not fetched by default on list, maybe separate
        reviews: []
    };
};

export const fetchProductsService = async (): Promise<Product[]> => {
    const { data, error } = await supabase
        .from('products')
        .select(`
      *,
      categories (
        name
      )
    `)
    // .order('created_at', { ascending: false }); // Column created_at does not exist in schema


    if (error) {
        console.error('Error fetching products:', error);
        throw error;
    }

    return (data || []).map(mapProductFromDB);
};

export const fetchProductByIdService = async (id: string): Promise<Product | null> => {
    const { data, error } = await supabase
        .from('products')
        .select(`
      *,
      categories (
        name
      ),
      reviews (*)
    `)
        .eq('id', id)
        .single();

    if (error) {
        console.error(`Error fetching product ${id}:`, error);
        return null;
    }

    const product = mapProductFromDB(data);
    // Map reviews if fetched
    if (data.reviews) {
        product.reviews = data.reviews.map((r: any) => ({
            id: r.id,
            author: r.author,
            rating: r.rating,
            comment: r.comment,
            date: r.date
        }));
    }

    return product;
};

export const createProductService = async (product: Partial<Product>): Promise<Product | null> => {
    // Basic validation or default mapping
    const dbPayload = {
        name: product.name,
        description: product.description,
        price: product.price,
        original_price: product.originalPrice,
        category_id: product.categoryId, // Must be ID
        brand: product.brand,
        image_url: product.imageUrl,
        hover_image_url: product.hoverImageUrl, // Added field
        stock: product.stock,
        is_new_release: product.isNewRelease,
        sizes: product.sizes,   // Added
        colors: product.colors,  // Added
        flavors: product.flavors // Added
        // id is usually generated by DB (uuid), but our schema expects TEXT ID. 
        // If we generate in frontend, pass it here. If not, generate uuid.
        // For now, let's assume valid ID or generate one if missing.
    };

    // Add ID if provided (or generate simple one if missing/needed by schema constraints)
    const payloadWithId = { ...dbPayload, id: product.id || crypto.randomUUID() };

    const { data, error } = await supabase
        .from('products')
        .insert([payloadWithId])
        .select()
        .single();

    if (error) {
        console.error('Error creating product:', error);
        throw error;
    }

    // Hack: We need category NAME for the UI, but insert result won't join categories immediately usually?
    // Supabase .select('*, categories(name)') works on insert too if named right.
    return { ...mapProductFromDB(data), category: product.category || 'Nova Categoria' }; // Fallback name
};


export const updateProductService = async (product: Product): Promise<void> => {
    const dbPayload = {
        name: product.name,
        description: product.description,
        price: product.price,
        original_price: product.originalPrice,
        category_id: product.categoryId,
        brand: product.brand,
        image_url: product.imageUrl,
        hover_image_url: product.hoverImageUrl, // Added field
        stock: product.stock,
        is_new_release: product.isNewRelease,
        sizes: product.sizes,   // Added
        colors: product.colors,  // Added
        flavors: product.flavors // Added
    };

    const { error } = await supabase
        .from('products')
        .update(dbPayload)
        .eq('id', product.id);

    if (error) {
        console.error('Error updating product:', error);
        throw error;
    }
};

export const deleteProductService = async (productId: string): Promise<void> => {
    const { error } = await supabase
        .from('products')
        .delete()
        .eq('id', productId);

    if (error) {
        console.error('Error deleting product:', error);
        throw error;
    }
};


export const fetchNewReleasesService = async (limit: number = 8): Promise<Product[]> => {
    const { data, error } = await supabase
        .from('products')
        .select(`
      *,
      categories (
        name
      )
    `)
        .eq('is_new_release', true)
        .limit(limit);

    if (error) {
        console.error('Error fetching new releases:', error);
        return [];
    }

    return (data || []).map(mapProductFromDB);
};

export const fetchBestSellersService = async (limit: number = 8): Promise<Product[]> => {
    const { data, error } = await supabase
        .from('products')
        .select(`
      *,
      categories (
        name
      )
    `)
        .order('sales_count', { ascending: false })
        .limit(limit);

    if (error) {
        console.error('Error fetching best sellers:', error);
        return [];
    }

    return (data || []).map(mapProductFromDB);
};

export const fetchOnSaleService = async (limit: number = 8): Promise<Product[]> => {
    // Note: This is a bit tricky with Supabase basic filters if we want "original_price > price".
    // We can use .not('original_price', 'is', null) and filter in client or use a more complex query.
    // However, .gt('original_price', supabase.rpc(...)) isn't straightforward without a function.
    // For now, let's fetch products with an original_price and filter client side if the dataset is small enough, 
    // OR ideally use a raw query or an RPC.
    // Let's try to filter where original_price is not null first, then sort by discount?
    // Actually, asking for specific "on sale" usually means original_price > price.
    // If we can't do column comparison easily in standard select, we might need to fetch a bit more and filter.
    // But to be safe and fast, let's just fetch items with original_price set, assuming they are on sale.
    // Better yet: Rpc call if possible, but let's stick to standard queries for simplicity unless user has rpc.
    // We'll fetch items where original_price is not null. 

    const { data, error } = await supabase
        .from('products')
        .select(`
      *,
      categories (
        name
      )
    `)
        .not('original_price', 'is', null)
        .limit(limit * 2); // Fetch a bit more to filter client side if needed

    if (error) {
        console.error('Error fetching on sale products:', error);
        return [];
    }

    // Client-side refinement for the comparison
    const products = (data || []).map(mapProductFromDB);
    return products.filter(p => p.originalPrice && p.originalPrice > p.price).slice(0, limit);
};
